<section class="white">
    <h3>Class</h3>
    <div>Normal class</div>
    <div>Data class</div>
    <div>Sealed class</div>
    <div>Enum class</div>
</section>
<!--Class-->
<section class="white">
    <h3>Normal class</h3>
    <pre><code class="hljs" data-trim>
							class Test

							class Test constructor(variable: Any)

							class Test constructor(variable: Any){
							init{
								val instanceVariable = variable
							}}

							class Person(val name: String, val hasSalary: Boolean){
								constructor(employee: Employee) : this(employee.name, true)
								constructor() :  this("",false)
							}
						</code></pre>
    <aside class="notes">
        <p>
            init block can be used if there is some calculation involved or something additional needs
            to be
            done, than just assigning the value
            instead of defining the empty constructor we can also use default values in the primary
            constructor.
            If the primary constructor does not have any annotations or visibility modifiers, the
            constructor keyword can be omitted
        </p>
    </aside>
</section>
<section class="white">
    <h3>Inheritance</h3>
    <pre><code class="hljs" data-trim>
                open class Base () {
                    open fun a(){}
                    open val c: Int = 1
                    fun b(){}
                }
                </code></pre>
    <pre><code class="hljs" data-trim>
                class Derived : Base(){
                    final override fun a() {}
                    override val c = 3
                }
                </code></pre>
    <aside class="notes">
        <p>
            In order to inherit from a class it needs to be open ("open" keyword)
            To override a function from the parent the function in the parent also needs to be declared
            "open"</p>
        <p>An overridden function is itself open. If you want to prohibit this, use final</p>
        <p>val basically defines a getter and a setter, so it can be overridden</p>
    </aside>
</section>
<section class="white">
    <h3>Data class</h3>
    <pre><code class="hljs" data-trim>
                data class User(val name: String, val age: Int)
            </code></pre>
    equals, copy, toString, getters and setter autogenerated:
    <pre><code class="hljs" data-trim>
                val user = User("Chris", 36)
                val copy = user.copy(age = 21)
                println(copy.equals(user)) //prints false
            </code></pre>
    <aside class="notes">
        <p>Kotlin generates automatically: getters, setters, toString, hashCode, equals, copy</p>
    </aside>
</section>
<section class="white">
    <h3>Enum</h3>

    <pre><code class="hljs" data-trim>
                 enum class ViewState{
                    ERROR,
                    DATA,
                    LOADING
                  }
            </code></pre>
</section>
<section class="white">
    <h3>Sealed classes</h3>

    <pre><code class="hljs" data-trim>
                    sealed class ViewState {
                        object Error: ViewState()
                        object Loading: ViewState()
                        data class Data(val someData: SomeData) : ViewState()
                    }
            </code></pre>
    <pre><code class="hljs" data-trim>
                fun handleViewState(viewState: ViewState): Unit = when(viewState){
                    is ViewState.Error -> { /* show error screen */ }
                    is ViewState.Loading -> { /* show loading indicator */ }
                    is ViewState.Data -> { handleData(viewState.someData)}
                }
            </code></pre>
    <aside class="notes">
        <p>Sealed classes are an extension of enums, they can contain state. A Sealed classes can group
            any
            type declaration: class, object</p>
        <p>Is usually useful in combination with "when"</p>
    </aside>
</section>