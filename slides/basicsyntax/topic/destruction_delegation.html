<section class="white"><h3>Destruction / Delegation</h3></section>
<section class="white">
    <h1>Class Delegation</h1>
    <p>«The interaction of inherited classes with their parents can be surprising and unpredicatable if
        the ancestor wasn't designed to be inherited from»
    </p>
</section>
<section class="white">
    <h2>Class Delegation</h2>
    <ul>
        <li>The Delegation pattern has proven to be a good alternative to inheritance
        </li>
        <li>
            Interaction with inherited classes can be unpredictable if the ancestor was not designed to
            be inherited from
        </li>
        <li>
            Kotlin supports it natively – no need to write the delegation explicitly
        </li>
        <li>
            You can delegate multiple classes
        </li>
        <li>
            Only share interface methods (not other methods and variables)
        </li>
    </ul>
</section>
<section class="white">
    <h2>Delegation design pattern</h2>
</section>
<section class="white">
    <h2>Implement class delegation</h2>
    <pre><code class="kotlin" data-trim>interface Base {
    fun print()
}
                </code></pre>
    <pre><code class="kotlin" data-trim>class BaseImpl1(val x: Int) : Base {
    override fun print() { print(x) }
}
                </code></pre>
    <pre><code class="kotlin" data-trim>
                    class Derived(b: Base) : Base by b
                </code></pre>
</section>
<section class="white">
    <h2>Usage of class delegation</h2>
    <pre><code class="kotlin" data-trim>fun main() {
    val b = BaseImpl1(10)
    Derived(b).print()
}
                     </code></pre>
    <aside class="notes">
        <p>
            The kotlin compiler will generate all overriding methods from both interfaces for us.
        </p>
    </aside>

</section>
<section class="white">
    <h1>Exercise 3</h1>
    <p>Implement a LoggableCollection using class delegation</p>
    <p>You can do this exercise in branch kotlinworkshop/exercise3 or in https://try.kotlinlang.org/</p>
    <p>it should implement all the features of a MutableCollection
        additionally to that it should log a message each time one or more elements have been added to
        the list</p>
</section>
<section class="white">
    <h1>Property Delegation</h1>

</section>
<section class="white">
    <h2>Implement Property Delegation</h2>
    <pre><code class="kotlin" data-trim>
                class Delegate {
                    operator fun getValue(
                        thisRef: Any?,
                        property: KProperty<*>
                    ): String { return "$thisRef, delegating '${property.name}' to me!"}
                    
                    operator fun setValue(
                        thisRef: Any?,
                        property: KProperty<*>,
                        value: String
                    ) { println("$value is assigned to '${property.name}' in $thisRef.") }
                }
                </code></pre>
</section>
<section class="white">
    <h2>Usage Property Delegation</h2>
    <pre><code class="kotlin" data-trim>
                class Example {
                    var p: String by Delegate()
                }
                </code></pre>
    <pre><code class="kotlin" data-trim>val e = Example()
println(e.p)
//prints: “Example@33a17727, delegating ‘p’ to me!”
                </code></pre>
</section>
<section class="white">
    <h2>Standard Property delegates</h2>
    <p><b>lazy()</b></p>
    <pre><code class="kotlin" data-trim>val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}
                </code></pre>
    <pre><code class="kotlin" data-trim>fun main() {
    println(lazyValue)
    println(lazyValue)
}
//prints: "computed" only once
                </code></pre>
</section>
<section class="white">
    <h2>Standard Property delegates</h2>
    <p><b>observable()</b></p>
    <ul>
        <li>
            takes an initial value and a handler as an argument
        </li>
        <li>
            the handler gets called each time when we assign a value to the property
        </li>
    </ul>
</section>
<section class="white">
    <h2>Standard Property delegates</h2>
    <p><b>map</b></p>
    <ul>
        <li>
            The map instance itself can be used as a delegate
        </li>
        <pre><code class="kotlin" data-trim>class MutableUser(val map: MutableMap&ltString&gt, Any?>) {
    var name: String by map
    var age: Int     by map
}
                </code></pre>
    </ul>
</section>
<section class="white">
    <h3>Exercise 4</h3>
    <p>Check out the branch kotlinworkshop/exercise4</p>
    <p>Find all the "TODO" (ctrl-shift-F) and follow the instructions</p>
</section>