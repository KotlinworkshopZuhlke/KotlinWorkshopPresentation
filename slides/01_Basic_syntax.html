<!doctype html>
<html>
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">

    <title>01 Intro | Example Content</title>

    <link rel="icon" href="../img/zuehlke_logo.jpg">
    <link rel="stylesheet" href="../css/reveal.css">
    <link rel="stylesheet" href="../css/theme/zuehlke.css">

    <!-- Theme used for syntax highlighting of code -->
    <link rel="stylesheet" href="../lib/css/atom-one-dark.css">

    <!-- Printing and PDF exports -->
    <script>
        var link = document.createElement('link');
        link.rel = 'stylesheet';
        link.type = 'text/css';
        link.href = window.location.search.match(/print-pdf/gi) ? '../css/print/pdf.css' : '../css/print/paper.css';
        document.getElementsByTagName('head')[0].appendChild(link);
    </script>
</head>
<body>
<div class="reveal">
    <div class="slides">
        <section class="deck-slide">
            <h1>Basic syntax</h1>
        </section>
        <!--Class / Object-->
        <section>
            <section><h3>Class / Object</h3></section>
            <!--Class-->
            <section>
                <section>
                    <h3>Classes</h3>
                    <div>Normal class</div>
                    <div>Data class</div>
                    <div>Sealed class</div>
                    <div>Enum class</div>
                </section>
                <section>
                    <h3>Normal class</h3>
                    <pre><code class="hljs" data-trim>
							class Test

							class Test constructor(variable: Any)

							class Test constructor(variable: Any){
							init{
								val instanceVariable = variable
							}}

							class Person(val name: String, val hasSalary: Boolean){
								constructor(employee: Employee) : this(employee.name, true)
								constructor() :  this("",false)
							}
						</code></pre>
                    <aside class="notes">
                        <p>
                            init block can be used if there is some calculation involved or something additional needs
                            to be
                            done, than just assigning the value
                            instead of defining the empty constructor we can also use default values in the primary
                            constructor.
                            If the primary constructor does not have any annotations or visibility modifiers, the
                            constructor keyword can be omitted
                        </p>
                    </aside>
                </section>
                <section>
                    <h3>Inheritance</h3>
                    <pre><code class="hljs" data-trim>
                open class Base () {
                    open fun a(){}
                    open val c: Int = 1
                    fun b(){}
                }
                </code></pre>
                    <pre><code class="hljs" data-trim>
                class Derived : Base(){
                    final override fun a() {}
                    override val c = 3
                }
                </code></pre>
                    <aside class="notes">
                        <p>
                            In order to inherit from a class it needs to be open ("open" keyword)
                            To override a function from the parent the function in the parent also needs to be declared
                            "open"</p>
                        <p>An overridden function is itself open. If you want to prohibit this, use final</p>
                        <p>val basically defines a getter and a setter, so it can be overridden</p>
                    </aside>
                </section>
                <section>
                    <h3>Data class</h3>
                    <pre><code class="hljs" data-trim>
                data class User(val name: String, val age: Int)
            </code></pre>
                    equals, copy, toString, getters and setter autogenerated:
                    <pre><code class="hljs" data-trim>
                val user = User("Chris", 36)
                val copy = user.copy(age = 21)
                println(copy.equals(user)) //prints false
            </code></pre>
                    <aside class="notes">
                        <p>Kotlin generates automatically: getters, setters, toString, hashCode, equals, copy</p>
                    </aside>
                </section>
                <section>
                    <h3>Enum</h3>

                    <pre><code class="hljs" data-trim>
                 enum class ViewState{
                    ERROR,
                    DATA,
                    LOADING
                  }
            </code></pre>
                </section>
                <section>
                    <h3>Sealed classes</h3>

                    <pre><code class="hljs" data-trim>
                    sealed class ViewState {
                        object Error: ViewState()
                        object Loading: ViewState()
                        data class Data(val someData: SomeData) : ViewState()
                    }
            </code></pre>
                    <pre><code class="hljs" data-trim>
                fun handleViewState(viewState: ViewState): Unit = when(viewState){
                    is ViewState.Error -> { /* show error screen */ }
                    is ViewState.Loading -> { /* show loading indicator */ }
                    is ViewState.Data -> { handleData(viewState.someData)}
                }
            </code></pre>
                    <aside class="notes">
                        <p>Sealed classes are an extension of enums, they can contain state. A Sealed classes can group
                            any
                            type declaration: class, object</p>
                        <p>Is usually useful in combination with "when"</p>
                    </aside>
                </section>
            </section>
            <!--Object-->
            <section>
                <section>
                    <h3>Object</h3>
                    <ul>
                        <li>Object as Singleton</li>
                        <li>Object expression as anonymous inner class</li>
                        <li>Companion objects as factory methods</li>
                    </ul>
                </section>
                <section>
                    <h3>Singleton</h3>
                    <pre><code class="hljs" data-trim>
                object Payroll {
                    val allEmployees = arrayListOf&ltPerson&gt()
                    fun calculateSalary() {
                        for (person in allEmployees) {...}
                    }
                }

                </code></pre>
                </section>
                <section>
                    <h3>Anonymus inner class</h3>
                    <pre><code class="hljs" data-trim>
object NoCaseFileComparator : Comparator&ltFile&gt {
    override fun compare(file1: File, file2: File): Int {
        return file1.path.compareTo(file2.path,
                ignoreCase = true)
} }
                </code></pre>
                    <pre><code class="hljs" data-trim>
val files = listOf(File("/Z"), File("/a"))
println(files.sortedWith(NoCaseFileComparator))
                </code></pre>
                </section>
                <section>
                    <h3>Companion Object</h3>
                    <pre><code class="hljs" data-trim>
class A {
    companion object {
        fun bar() {
            println("Companion object called")
         }
     }
}
            </code></pre>
                    bar can be called like this:
                    <pre><code class="hljs" data-trim>
                A.bar()
                </code></pre>
                </section>


            </section>
        </section>
        <!--Destruction / Delegation-->
        <section>
            <section><h3>Destruction / Delegation</h3></section>
            <section>
                <section>
                    <h1>Class Delegation</h1>
                    <p>«The interaction of inherited classes with their parents can be surprising and unpredicatable if
                        the ancestor wasn't designed to be inherited from»
                    </p>

                </section>
                <section>
                    <h2>Class Delegation</h2>
                    <ul>
                        <li>The Delegation pattern has proven to be a good alternative to inheritance
                        </li>
                        <li>
                            Interaction with inherited classes can be unpredictable if the ancestor was not designed to
                            be inherited from
                        </li>
                        <li>
                            Kotlin supports it natively – no need to write the delegation explicitly
                        </li>
                        <li>
                            You can delegate multiple classes
                        </li>
                        <li>
                            Only share interface methods (not other methods and variables)
                        </li>
                    </ul>
                </section>
                <section>
                    <h2>Delegation design pattern</h2>
                    <img src="/img/delegation-pattern.png" height="300">
                </section>
                <section>
                    <h2>Implement class delegation</h2>
                    <pre><code class="kotlin" data-trim>interface Base {
    fun print()
}
                </code></pre>
                    <pre><code class="kotlin" data-trim>class BaseImpl1(val x: Int) : Base {
    override fun print() { print(x) }
}
                </code></pre>
                    <pre><code class="kotlin" data-trim>
                    class Derived(b: Base) : Base by b
                </code></pre>
                </section>
                <section>
                    <h2>Usage of class delegation</h2>
                    <pre><code class="kotlin" data-trim>fun main() {
    val b = BaseImpl1(10)
    Derived(b).print()
}
                     </code></pre>
                    <aside class="notes">
                        <p>
                            The kotlin compiler will generate all overriding methods from both interfaces for us.
                        </p>
                    </aside>

                </section>
                <section>
                    <h1>Exercise 3</h1>
                    <p>Implement a LoggableCollection using class delegation</p>
                    <p>You can do this exercise in branch kotlinworkshop/exercise3 or in https://try.kotlinlang.org/</p>
                    <p>it should implement all the features of a MutableCollection
                        additionally to that it should log a message each time one or more elements have been added to
                        the list</p>
                </section>
            </section>


            <section>
                <section>
                    <h1>Property Delegation</h1>

                </section>
                <section>
                    <h2>Implement Property Delegation</h2>
                    <pre><code class="kotlin" data-trim>
                class Delegate {
                    operator fun getValue(
                        thisRef: Any?,
                        property: KProperty<*>
                    ): String { return "$thisRef, delegating '${property.name}' to me!"}
                    
                    operator fun setValue(
                        thisRef: Any?,
                        property: KProperty<*>,
                        value: String
                    ) { println("$value is assigned to '${property.name}' in $thisRef.") }
                }
                </code></pre>
                </section>
                <section>
                    <h2>Usage Property Delegation</h2>
                    <pre><code class="kotlin" data-trim>
                class Example {
                    var p: String by Delegate()
                }
                </code></pre>
                    <pre><code class="kotlin" data-trim>val e = Example()
println(e.p)
//prints: “Example@33a17727, delegating ‘p’ to me!”
                </code></pre>
                </section>
                <section>
                    <h2>Standard Property delegates</h2>
                    <p><b>lazy()</b></p>
                    <pre><code class="kotlin" data-trim>val lazyValue: String by lazy {
    println("computed!")
    "Hello"
}
                </code></pre>
                    <pre><code class="kotlin" data-trim>fun main() {
    println(lazyValue)
    println(lazyValue)
}
//prints: "computed" only once
                </code></pre>
                </section>
                <section>
                    <h2>Standard Property delegates</h2>
                    <p><b>observable()</b></p>
                    <ul>
                        <li>
                            takes an initial value and a handler as an argument
                        </li>
                        <li>
                            the handler gets called each time when we assign a value to the property
                        </li>
                    </ul>
                </section>
                <section>
                    <h2>Standard Property delegates</h2>
                    <p><b>map</b></p>
                    <ul>
                        <li>
                            The map instance itself can be used as a delegate
                        </li>
                        <pre><code class="kotlin" data-trim>class MutableUser(val map: MutableMap&ltString&gt, Any?>) {
    var name: String by map
    var age: Int     by map
}
                </code></pre>
                    </ul>
                </section>
                <section>
                    <h3>Exercise 4</h3>
                    <p>Check out the branch kotlinworkshop/exercise4</p>
                    <p>Find all the "TODO" (ctrl-shift-F) and follow the instructions</p>
                </section>
            </section>
        </section>
        <!--Field / Property-->
        <section>
            <section><h3>Fields and Properties</h3></section>
            <section>
                <pre><code class="hljs" data-trim>
class Person {
    var firstname: String = "Celine"
    var lastname: String = "Heldner"
}
            </code></pre>
                We can use "Person" like this
                <pre><code class="hljs" data-trim>
                val person = Person()
                println(person.firstname ) //has no setter only getter
                person.lastname = "newName" //has setter and getter
            </code></pre>
                <aside class="notes">
                    <p>Even though properties look like java fields, they are a completely different concept</p>
                    <p>Distinguish between mutable and immutable var vs val</p>
                    <p>Implicitely there will be a getter and/or setter provided by Kotlin</p>
                </aside>
            </section>
            <section>
                Mutable variable with a public getter and private setter
                <pre><code class="hljs" data-trim>
                    var name: String = "Celine"
                        private set
                </code></pre>
                <pre><code class="hljs" data-trim>
                    var name: String = "Celine"
                        get() = field
                        set(value){
                            if (value != null){
                                field = value
                            }
                        }
                </code></pre>
                <aside class="notes">
                    <p>Inside custom setters and getters you can define/access the backing field</p>
                </aside>
            </section>
        </section>
        <!--Nullability / Mutability / Immutability-->
        <section>
            <section><h3>Nullability / Mutability / Immutability</h3></section>
            <!-- Operators & Coercion -->
            <section>
                <section>
                    <h2>Operators &amp; Coercion</h2>
                    <h3>Definition of &laquo;Coercion&raquo;</h3>
                    <p>In computer science, type conversion, typecasting, and coercion are different ways of, implicitly
                        or
                        explicitly, changing an entity of one data type into another.</p>
                    <p>Coercion /kəʊˈəːʃ(ə)n/ &rightarrow; der Zwang, die Nötigung</p>
                </section>
                <section>
                    <h2>Operators &amp; Coercion</h2>
                    <h3>What does this mean in practice?</h3>
                    <p>If the operands of an operator are of different types, one of them will be converted. The
                        <a href="http://delapouite.com/ramblings/javascript-coercion-rules.html" target="_blank">coercion
                            rules</a> are quite extensive.</p>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        0 == true; // false because true is converted to 1
                        1 == "1"; // true because 1 is converted to "1"
                        let x = 0 + ""; // x will be a string "0"
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Operators &amp; Coercion</h2>
                    <h3>Loose vs. Strict Equals</h3>
                    <ul>
                        <li>Loose equals <span class="code">==</span> uses coercion</li>
                        <li>Strict equals <span class="code">===</span> doesn't change the types</li>
                    </ul>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        1 == "1"; // true
                        1 === "1"; // false
                    </code>
                </pre>
                    <div class="fragment tip">In your daily life, use strict equals only!</div>
                </section>
                <section>
                    <h2>Operators &amp; Coercion</h2>
                    <h3>Logical Operators</h3>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        true && 42; // Returns second expression --> 42
                        false || 42 || true; // Returns first "true" expression
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Try it yourself</h2>
                    <p>Open the console (F12 on windows, CMD + alt + I on Mac) and play around!</p>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        1 == "1"
                        1 === true
                        NaN === NaN
                        undefined == undefined
                        // be creative!
                    </code>
                </pre>
                </section>
            </section>
            <!-- Truthy & Falsy -->
            <section>
                <section>
                    <h2>Truthy &amp; Falsy</h2>
                    <ul>
                        <li>Due to coercion everything can be converted to a <span class="warn">boolean</span></li>
                        <li>Therefore every value is either <span class="warn">truthy</span> or <span
                                class="warn">falsy</span></li>
                    </ul>
                </section>
                <section>
                    <h2>Truthy &amp; Falsy</h2>
                    <h3>The six falsy cases</h3>
                    <ul>
                        <li><span class="code">false</span></li>
                        <li><span class="code">0</span> (zero)</li>
                        <li><span class="code">''</span> or <span class="code">""</span> (empty string)</li>
                        <li><span class="code">null</span></li>
                        <li><span class="code">undefined</span></li>
                        <li><span class="code">NaN</span> (Not a Number, e.g. the result of 1/0)</li>
                    </ul>
                </section>
                <section>
                    <h2>Truthy &amp; Falsy</h2>
                    <p>Everything else is <span class="warn">truthy</span>!</p>
                    <p>Makes it easy to check whether a variable is present:</p>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let x = 'Hello World';
                        if (x) { // Truthy
                            doSomething();
                        }

                        let y = 0;
                        if (y) { // Falsy
                            doSomething();
                        }
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Truthy &amp; Falsy</h2>
                    <p>Shorthand for safe variable declaration:</p>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let x = undefined;

                        let y = x || 'default';
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Truthy &amp; Falsy</h2>
                    <p>Try it yourself!</p>
                    <p data-height="330" data-editable="true" data-theme-id="0" data-slug-hash="dJMGjL"
                       data-default-tab="js,result"
                       data-user="enpayne" data-embed-version="2" data-pen-title="Truthy & Falsy" class="codepen">See
                        the
                        Pen <a href="https://codepen.io/enpayne/pen/dJMGjL/">Truthy & Falsy</a> by Nicolas Oeschger (<a
                                href="https://codepen.io/enpayne">@enpayne</a>) on <a
                                href="https://codepen.io">CodePen</a>.
                    </p>
                    <script async src="https://production-assets.codepen.io/assets/embed/ei.js"></script>
                </section>
            </section>
            <!-- Strict Mode -->
            <section>
                <section>
                    <h2>Strict Mode</h2>
                    <div class="badge-container">
                        <span class="badge es5"></span>
                    </div>
                    <ul>
                        <li>Opts in a restricted variant of JavaScript</li>
                        <li>Not a subset but <span class="warn">different</span> semantics</li>
                        <li>Strict mode and non-strict mode code can coexist</li>
                        <li>Not supported by all browsers</li>
                    </ul>
                </section>
                <section>
                    <h2>Strict Mode</h2>
                    <div class="badge-container">
                        <span class="badge es5"></span>
                    </div>
                    <ol>
                        <li>Eliminates some JavaScript silent errors<br>&rightarrow; Throw errors</li>
                        <li>Fixes mistakes that make it difficult for JavaScript engines to perform optimizations<br>&rightarrow;
                            Runs faster
                        </li>
                        <li>Prohibits some syntax likely to be defined in future versions of ECMAScript</li>
                    </ol>
                </section>
                <section>
                    <h2>Strict Mode</h2>
                    <h3>How to invoke it?</h3>
                    <p>For scripts:</p>
                    <div class="badge-container">
                        <span class="badge es5"></span>
                    </div>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        // Whole-script strict mode syntax
                        'use strict';
                        var v = "Hi! I'm a strict mode script!";
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Strict Mode</h2>
                    <h3>How to invoke it?</h3>
                    <p>For functions:</p>
                    <div class="badge-container">
                        <span class="badge es5"></span>
                    </div>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        function strict() {
                            'use strict';
                            return "Hi!  I'm a strict mode function!";
                        }

                        function notStrict() {
                            return "I'm not strict.";
                        }
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Strict Mode</h2>
                    <h3>Further information</h3>
                    <div class="badge-container">
                        <span class="badge es5"></span>
                    </div>
                    <p>If you want to learn more about what <span class="code">strict mode</span> is doing exactly, we
                        recommend reading
                        <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode"
                           target="_blank">this</a> article.</p>
                </section>
            </section>
            <!-- Strings -->
            <section>
                <section>
                    <h2>Strings</h2>
                    <h3>Definition</h3>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let aString = "I'm a string";
                        let anotherString = '"Me" too!';
                    </code>
                </pre>
                    <p><span class="code">""</span> and <span class="code">''</span> are equivalent. It only depends
                        which
                        is more convenient regarding the content of the string.<br>E.g. <span
                                class="code">"Don't"</span>
                        vs. <span class="code">'Don\'t'</span></p>
                </section>
                <section>
                    <h2>Strings</h2>
                    <h3>Concatenation</h3>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let a = "I'm a";
                        let b = 'string!';
                        let c = a + ' ' + c;
                        <span class="fragment">// I'm a string!</span>

                        <span class="fragment">let d = a.concat(' ', b);</span>
                        <span class="fragment">// I'm a string!</span>
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Strings</h2>
                    <h3>Template Literals</h3>
                    <div class="badge-container">
                        <span class="badge es6"></span>
                    </div>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let x = 'String';
                        let aString = `I'm a "${x}" too!`;

                        <span class="fragment">// I'm a "String" too!</span>
                    </code>
                </pre>
                    <p>You can use single and double quotes as well as variables without concatenation using ES6 <span
                            class="warn">template literals</span> with back ticks (<span class="code">``</span>).</p>
                </section>
                <section>
                    <h2>Strings</h2>
                    <h3>Template Literals II</h3>
                    <div class="badge-container">
                        <span class="badge es6"></span>
                    </div>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let aString = `It's even possible
                        to add line breaks!`;

                        <span class="fragment">// It's even possible<br>// to add line breaks!</span>
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Strings</h2>
                    <h3>Template Literals III</h3>
                    <div class="badge-container">
                        <span class="badge es6"></span>
                    </div>
                    <pre>
                    <code class="hljs javascript" data-trim contenteditable data-noescape>
                        let x;
                        `The value is: ${x ? x : 'not defined'}!`;
                        <span class="fragment">// The value is: not defined!</span>

                        x = 'test';
                        `The value is: ${x ? x : 'not defined'}`;
                        <span class="fragment">// The value is: test!</span>
                    </code>
                </pre>
                </section>
                <section>
                    <h2>Strings</h2>
                    <h3>Useful Functions</h3>
                    <ul>
                        <li><span class="code">substring()</span></li>
                        <li><span class="code">toLowerCase()</span> & <span class="code">toUpperCase()</span></li>
                        <li><span class="code">startsWith()</span> & <span class="code">endsWith()</span></li>
                        <li>etc.</li>
                    </ul>
                    <p>See <a
                            href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/String"
                            target="_blank">here</a> for a complete list.</p>
                </section>
            </section>
            <!-- Exercise -->
            <section class="deck-slide">
                <h3>Exercise 2</h3>
                <p>Check out the branch kotlinworkshop/exercise2</p>
                <p>Find all the "TODO" (ctrl-shift-F) and follow the instructions</p>
            </section>
        </section>
        <!--Function-->
        <section>
            <section><h3>Function</h3></section>
            <section>
                <h3>Functions</h3>

                Long form
                <pre><code class="hljs" data-trim>
	fun sum(a: Int, b: Int): Int {
	  return a + b
	}
						</code></pre>
                Short form
                <pre><code class="hljs" data-trim>
	fun sum(a: Int, b: Int) = a + b
						</code></pre>
                <aside class="notes">
                    <p>no primitive types: all objects, Int, String, Boolean, Double...</p>
                </aside>
            </section>
            <section>
                <h3>Default values and named parameters</h3>

                <pre><code class="hljs" data-trim>
fun sum(a: Int = 10, b: Int): Int {
	return a + b
}
						</code></pre>
                Called with named parameters
                <pre><code class="hljs" data-trim>
sum(b = 2)
sum(a = 2, b = 5)
						</code></pre>
                <aside class="notes">
                    <p>If you define a parameter which follows a parameter with a default value cou can only call this
                        method with it‘s named parameters.
                    </p>
                </aside>
            </section>
            <section>
                <h3>Function type</h3>
                <pre><code class="hljs" data-trim>
							() -> Unit
							(Int) -> Double
							() -> () -> ()
						</code></pre>
                Lambda expressions
                <pre><code class="hljs" data-trim>
val divideByHalf: (Int) -> Int = { x -> x / 2 } //lambda expression
val divideByHalf = fun(x: Int) = x/2 //anonymous function
						</code></pre>
                <aside class="notes">
                    <p>
                        Functions can have types and can be passed around.
                    </p>
                    <p>
                        The big difference between them is the fact that lambda expressions return the value of the last
                        statement in its body or Unit and unlabeled return is not working.
                    </p>
                </aside>
            </section>
            <section>
                <h3>Higher order functions</h3>
                <pre><code class="hljs" data-trim>
							fun isOdd(x: Int) = x % 2 != 0
							val listOfNumbers = mutableListOf&ltInt&gt(1,2,3,4)

							listOfNumbers.filter(::isOdd)
							listOfNumbers.filter { isOdd(it) }

						</code></pre>
                <aside class="notes">
                    <p>
                        Explain Mutability and Immutability for lists what is "mutableListOF()"
                        Here ::isOdd is a value of function type (Int) -> Boolean.
                        :: creates a member reference or a class reference
                    </p>
                </aside>
            </section>
            <section>
                <section>
                    <h2>Std Lib Scope functions</h2></section>
                <section>
                    <h3>Scope functions</h3>
                    <ul>
                        <li><b>let</b></li>
                        <li><b>apply</b></li>
                        <li>run</li>
                        <li>also</li>
                        <li>with</li>
                        <li>takeif</li>
                    </ul>
                </section>
                <section>
                    <h3>Let</h3>
                    <pre><code class="kotlin" data-trim>fun &ltT, R&gt T.let(f: (T) -> R): R = f(this)
                    </code></pre>
                    <p>Is very useful with the null-check operator ?</p>
                    <pre><code class="kotlin" data-trim>val map : Map&ltString, String&gt = ...
val config = map[key]config?.let {
//This block will not be exectuted if „config“ is null
}
                    </code></pre>
                </section>
                <section>
                    <h3>Apply</h3>
                    <pre><code class="kotlin" data-trim>fun &ltT&gt T.apply(f: T.() -> Unit): T { f(); return this }
                    </code></pre>
                    <p>With ‘apply()’ we can substitute the ‘Builder’ pattern or simply make code more readable
                    </p>
                    <pre><code class="kotlin" data-trim>val recyclerView: ReyclerView = RecyclerView().apply{
    setHasFixedSize = true
    layoutManager = LinearLayoutManager(context)
    adapter = MyAdapter(context)
    clearOnScrollListener()}
}
                    </code></pre>
                </section>
            </section>
        </section>
        <!--Collection-->
        <section>
            <section>
                <h3>Collection</h3>
                List
                <pre><code class="kotlin" data-trim>
                    listOf(2,3)
                    mutableListOf&ltInt&gt()
                </code></pre>
                Set
                <pre><code class="kotlin" data-trim>
                    setOf(2,3)
                    mutableSetOf&ltInt&gt()
                </code></pre>
                Map
                <pre><code class="kotlin" data-trim>
                    mapOf("Hello" to "Hallo", "Bye" to "Tschüss")
                    mutableMapOf&ltString,String&gt()
                </code></pre>
            </section>
            <section>
                <h3>Useful functions on collections</h3>
                foreach{...}
                <pre><code class="kotlin" data-trim>
                    val numbers = listOf("one", "two", "three", "four")
numbers.forEach {
    println(it)
}
                </code></pre>
                map{...}
                <pre><code class="kotlin" data-trim>
                    val numbers = setOf(1, 2, 3)
println(numbers.map { it * 3 })
//prints 3, 6, 9
                </code></pre>
                filter{...}
                <pre><code class="kotlin" data-trim>
                    val numbers = listOf("one", "two", "three", "four")
val longerThan3 = numbers.filter { it.length > 3 }
println(longerThan3)
                </code></pre>
            </section>
            <section>
                <h3>Many more useful functions</h3>
                <a href="https://kotlinlang.org/docs/reference/collection-transformations.html">
                    https://kotlinlang.org/docs/reference/collection-transformations.html</a>
            </section>
        </section>
    </div>
</div>

<script src="../lib/js/head.min.js"></script>
<script src="../js/reveal.js"></script>

<script>
    // More info https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
        history: true,

        // More info https://github.com/hakimel/reveal.js#dependencies
        dependencies: [
            {src: '../plugin/markdown/marked.js'},
            {src: '../plugin/markdown/markdown.js'},
            {src: '../plugin/notes/notes.js', async: true},
            {
                src: '../plugin/highlight/highlight.js', async: true, callback: function () {
                    hljs.initHighlightingOnLoad();
                }
            }
        ]
    });
</script>
</body>
</html>
